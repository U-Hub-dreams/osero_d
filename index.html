<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>強さ優先 Webオセロ（合法手に探索評価表示）</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1b34;
      --board:#0b3f2a;
      --cell:#0e5639;
      --grid:#0a2f1f;
      --text:#e6eefc;
      --muted:#9fb1d6;
      --accent:#60a5fa;
      --good:#34d399;
      --bad:#fb7185;
      --warn:#fbbf24;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 0%, #14224a 0%, var(--bg) 60%);
      color:var(--text);
    }
    .wrap{
      max-width: 1180px;
      margin: 20px auto;
      padding: 16px;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:16px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border:1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .title{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .title h1{
      font-size: 18px;
      margin:0;
      letter-spacing: .02em;
    }
    .title .sub{
      font-size: 12px;
      color: var(--muted);
    }
    .board{
      width: min(72vh, 660px);
      aspect-ratio: 1 / 1;
      margin: 0 auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border-radius: 18px;
      padding: 12px;
      border:1px solid rgba(255,255,255,0.12);
    }
    .grid{
      width:100%;
      height:100%;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: 6px;
      background: var(--grid);
      padding: 6px;
      border-radius: 14px;
    }
    .cell{
      position:relative;
      border-radius: 12px;
      background: radial-gradient(140px 140px at 20% 20%, rgba(255,255,255,0.12), rgba(255,255,255,0.02)),
                  linear-gradient(180deg, #0f6b47, var(--cell));
      border:1px solid rgba(0,0,0,0.25);
      cursor:pointer;
      user-select:none;
      overflow:hidden;
    }
    .cell:hover{
      outline: 2px solid rgba(96,165,250,0.45);
      outline-offset: -2px;
    }
    .disc{
      position:absolute;
      inset: 12%;
      border-radius:999px;
      box-shadow: 0 10px 16px rgba(0,0,0,0.35);
    }
    .black{
      background: radial-gradient(140px 140px at 30% 25%, #3b3b3b 0%, #0c0c0c 55%, #000 100%);
    }
    .white{
      background: radial-gradient(140px 140px at 30% 25%, #ffffff 0%, #e6e6e6 55%, #cfcfcf 100%);
    }

    .hint{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 12.5px;
      font-weight: 900;
      letter-spacing: .02em;
      text-shadow: 0 2px 10px rgba(0,0,0,0.55);
      pointer-events:none;
    }
    .hint .badge{
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(15, 27, 52, 0.74);
      border: 1px solid rgba(255,255,255,0.14);
      min-width: 58px;
      text-align:center;
      backdrop-filter: blur(4px);
    }
    .hint.good .badge{ color: var(--good); }
    .hint.bad .badge{ color: var(--bad); }
    .hint.neutral .badge{ color: #d7e3ff; }

    .right .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(15,27,52,0.55);
      border:1px solid rgba(255,255,255,0.10);
      color: var(--text);
      font-size: 13px;
    }
    .dot{
      width:10px;height:10px;border-radius:99px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(96,165,250,0.18);
    }
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{
      cursor:pointer;
      border:none;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(96,165,250,0.18);
      color: var(--text);
      border: 1px solid rgba(96,165,250,0.35);
      font-weight: 800;
      letter-spacing: .01em;
    }
    button:hover{background: rgba(96,165,250,0.28)}
    button:active{transform: translateY(1px)}
    button.secondary{
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
    }
    button.secondary:hover{background: rgba(255,255,255,0.10)}
    .small{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
    }
    .kv{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
    }
    .kv .box{
      padding: 10px;
      border-radius: 14px;
      background: rgba(15,27,52,0.45);
      border:1px solid rgba(255,255,255,0.10);
    }
    .box h3{
      margin:0 0 6px 0;
      font-size: 13px;
      color: #cfe0ff;
      letter-spacing: .02em;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      color: #d7e3ff;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(15,27,52,0.45);
      border:1px solid rgba(255,255,255,0.10);
      font-size: 13px;
    }
    input[type="checkbox"]{transform: scale(1.1)}
    select, input[type="number"]{
      background: rgba(15,27,52,0.65);
      color: var(--text);
      border:1px solid rgba(255,255,255,0.14);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 800;
      width: 120px;
    }
    .warn{
      color: var(--warn);
      font-weight: 800;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="title">
        <h1>強さ優先 Webオセロ：合法手に「探索評価値」表示</h1>
        <div class="sub">黒/白のどちらでもAIにできる（右の設定）</div>
      </div>

      <div class="board">
        <div id="grid" class="grid" aria-label="Othello board"></div>
      </div>

      <div class="small" style="margin-top:10px;">
        表示している数値は「その手を選んだときの最善値（αβ探索）」です。<br/>
        スコアは手番側にとって大きいほど良い（+ が有利 / - が不利）。終盤は石差の比重が強くなります。
      </div>
    </div>

    <div class="card right">
      <div class="row">
        <span class="pill"><span class="dot"></span><span id="turnLabel">手番：黒</span></span>
        <span class="pill">黒 <b id="blackCount">2</b> / 白 <b id="whiteCount">2</b></span>
        <span class="pill">空き <b id="emptyCount">60</b></span>
      </div>

      <div class="row">
        <label class="toggle">
          <input id="showEval" type="checkbox" checked />
          合法手の探索評価を表示
        </label>

        <label class="toggle">
          <span>AI</span>
          <select id="aiSide">
            <option value="WHITE" selected>白がAI</option>
            <option value="BLACK">黒がAI</option>
            <option value="NONE">AIなし</option>
          </select>
        </label>
      </div>

      <div class="row">
        <label class="toggle">
          <span>思考(ms)</span>
          <input id="thinkMs" type="number" min="50" max="5000" value="800" />
        </label>
        <label class="toggle">
          <span>最大深さ</span>
          <input id="maxDepth" type="number" min="2" max="20" value="11" />
        </label>
      </div>

      <div class="btns">
        <button id="aiMoveBtn">AIに1手打たせる</button>
        <button id="undoBtn" class="secondary">1手戻す</button>
        <button id="resetBtn" class="secondary">初期化</button>
        <button id="passBtn" class="secondary">パス（手が無い時）</button>
      </div>

      <div class="kv">
        <div class="box">
          <h3>強さの中身</h3>
          <div class="small">
            ・反復深化＋αβ（手の並べ替えあり）<br/>
            ・Zobristハッシュ＋TT（置換表）<br/>
            ・評価：角/辺、危険マス(C/X)、モビリティ、フロンティア、石差（終盤強め）、簡易安定度、パリティ<br/>
            <span class="warn">※ 端末性能により深さが伸びます（思考msを増やすほど強い）。</span>
          </div>
        </div>

        <div class="box">
          <h3>ログ</h3>
          <div id="debug" class="mono"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== 基本定数 ======
  const N = 8;
  const EMPTY = 0, BLACK = 1, WHITE = -1;
  const INF = 1e15;

  const DIRS = [
    [-1,-1],[-1,0],[-1,1],
    [ 0,-1],       [ 0,1],
    [ 1,-1],[ 1,0],[ 1,1],
  ];

  // 位置重み（強めの形）
  const PST = [
    [120,-20, 20,  5,  5, 20,-20,120],
    [-20,-60, -5, -5, -5, -5,-60,-20],
    [ 20, -5, 15,  3,  3, 15, -5, 20],
    [  5, -5,  3,  3,  3,  3, -5,  5],
    [  5, -5,  3,  3,  3,  3, -5,  5],
    [ 20, -5, 15,  3,  3, 15, -5, 20],
    [-20,-60, -5, -5, -5, -5,-60,-20],
    [120,-20, 20,  5,  5, 20,-20,120],
  ];

  const CORNERS = [[0,0],[0,7],[7,0],[7,7]];
  const X_SQ = [[1,1],[1,6],[6,1],[6,6]]; // 角斜め（X）
  const C_SQ = [[0,1],[1,0],[0,6],[1,7],[6,0],[7,1],[6,7],[7,6]]; // 角隣接（C）

  // ====== UI ======
  const gridEl = document.getElementById("grid");
  const turnLabel = document.getElementById("turnLabel");
  const blackCountEl = document.getElementById("blackCount");
  const whiteCountEl = document.getElementById("whiteCount");
  const emptyCountEl = document.getElementById("emptyCount");
  const debugEl = document.getElementById("debug");

  const showEvalEl = document.getElementById("showEval");
  const aiSideEl = document.getElementById("aiSide");
  const thinkMsEl = document.getElementById("thinkMs");
  const maxDepthEl = document.getElementById("maxDepth");

  const aiMoveBtn = document.getElementById("aiMoveBtn");
  const undoBtn = document.getElementById("undoBtn");
  const resetBtn = document.getElementById("resetBtn");
  const passBtn = document.getElementById("passBtn");

  // ====== 状態 ======
  let board = makeEmptyBoard();
  let turn = BLACK;
  let history = [];

  // TT（置換表）
  // key: hash (string) -> { depth, flag, value, bestMoveKey }
  // flag: 0 exact, 1 lowerbound, 2 upperbound
  const TT = new Map();

  // Zobrist
  const Z = initZobrist();
  let hash = 0n;

  // 反復深化の管理
  let thinking = false;

  // ====== 初期化 ======
  initBoard(board);
  hash = computeHash(board);
  buildGrid();
  render();
  maybeAutoAIMove();

  // ====== イベント ======
  showEvalEl.addEventListener("change", render);
  aiSideEl.addEventListener("change", () => { render(); maybeAutoAIMove(); });
  thinkMsEl.addEventListener("change", () => { /* noop */ });
  maxDepthEl.addEventListener("change", () => { /* noop */ });

  aiMoveBtn.addEventListener("click", async () => {
    if (thinking) return;
    await doAIMoveIfNeeded(true);
  });

  undoBtn.addEventListener("click", () => {
    if (history.length === 0 || thinking) return;
    const prev = history.pop();
    board = prev.board;
    turn = prev.turn;
    hash = prev.hash;
    render();
  });

  resetBtn.addEventListener("click", () => {
    if (thinking) return;
    board = makeEmptyBoard();
    initBoard(board);
    turn = BLACK;
    history = [];
    TT.clear();
    hash = computeHash(board);
    render();
    maybeAutoAIMove();
  });

  passBtn.addEventListener("click", () => {
    if (thinking) return;
    const moves = getLegalMoves(board, turn);
    if (moves.length > 0) {
      flashDebug("まだ合法手があります。パスは不要です。");
      return;
    }
    pushHistory();
    turn = -turn;
    render();
    maybeAutoAIMove();
  });

  // ====== 盤面 ======
  function makeEmptyBoard(){
    return Array.from({length:N}, () => Array(N).fill(EMPTY));
  }
  function cloneBoard(b){ return b.map(r => r.slice()); }
  function initBoard(b){
    b[3][3]=WHITE; b[3][4]=BLACK;
    b[4][3]=BLACK; b[4][4]=WHITE;
  }
  function inBounds(r,c){ return r>=0 && r<N && c>=0 && c<N; }

  function getFlips(b, r, c, player){
    if (b[r][c] !== EMPTY) return [];
    const opp = -player;
    let flips = [];
    for (const [dr,dc] of DIRS){
      let rr=r+dr, cc=c+dc;
      let line=[];
      while (inBounds(rr,cc) && b[rr][cc]===opp){
        line.push([rr,cc]);
        rr+=dr; cc+=dc;
      }
      if (line.length>0 && inBounds(rr,cc) && b[rr][cc]===player){
        flips = flips.concat(line);
      }
    }
    return flips;
  }

  function getLegalMoves(b, player){
    const res=[];
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const flips = getFlips(b,r,c,player);
        if (flips.length) res.push({r,c,flips});
      }
    }
    return res;
  }

  function applyMoveInPlace(b, move, player){
    // in-place + hash 更新用に返り値として変更箇所を返す
    const changed = [];
    b[move.r][move.c] = player;
    changed.push([move.r, move.c, EMPTY, player]);
    for (const [rr,cc] of move.flips){
      const prev = b[rr][cc];
      b[rr][cc] = player;
      changed.push([rr, cc, prev, player]);
    }
    return changed;
  }

  function undoMoveInPlace(b, changed){
    for (let i=changed.length-1;i>=0;i--){
      const [r,c,prev,_now] = changed[i];
      b[r][c] = prev;
    }
  }

  function countDiscs(b){
    let black=0, white=0, empty=0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (b[r][c]===BLACK) black++;
        else if (b[r][c]===WHITE) white++;
        else empty++;
      }
    }
    return {black,white,empty};
  }

  // ====== Zobrist ======
  function initZobrist(){
    // [r][c][pieceIndex] pieceIndex: 0 black, 1 white
    const z = Array.from({length:N}, () =>
      Array.from({length:N}, () => [rand64(), rand64()])
    );
    const side = rand64();
    return {z, side};
  }
  function rand64(){
    // BigInt 64bit 擬似乱数（ブラウザ標準の crypto を使用）
    const u = new Uint32Array(2);
    crypto.getRandomValues(u);
    return (BigInt(u[0]) << 32n) ^ BigInt(u[1]);
  }
  function computeHash(b){
    let h=0n;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (b[r][c]===BLACK) h ^= Z.z[r][c][0];
        else if (b[r][c]===WHITE) h ^= Z.z[r][c][1];
      }
    }
    if (turn===BLACK) h ^= Z.side;
    return h;
  }
  function hashToggleSide(h){ return h ^ Z.side; }
  function hashXorPiece(h, r, c, piece){
    if (piece===BLACK) return h ^ Z.z[r][c][0];
    if (piece===WHITE) return h ^ Z.z[r][c][1];
    return h;
  }

  function moveKey(m){ return (m.r<<3) | m.c; }
  function keyToRC(k){ return {r:(k>>3)&7, c:k&7}; }

  // ====== 評価関数（強め・フェーズ依存） ======
  // スコアは「player視点で大きいほど良い」
  function evaluate(b, player){
    const {black, white, empty} = countDiscs(b);
    const discs = black + white;
    const phase = discs / 64; // 0->1

    // フェーズで重みを変える（序盤:モビリティ/危険回避、中盤:形、終盤:石差）
    const wMob = lerp(18, 6, phase);
    const wPos = lerp(10, 16, phase);
    const wDisc = lerp(1, 28, phase);      // 終盤ほど石差を強く
    const wFrontier = lerp(10, 4, phase);  // 序盤ほどフロンティア（外周石）を嫌う
    const wCorner = 60;
    const wParity = lerp(0, 8, phase);     // 終盤寄りで効かせる
    const wStab = lerp(0, 10, phase);      // 簡易安定度

    // 位置重み
    let pos=0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        pos += PST[r][c] * b[r][c];
      }
    }
    pos *= player;

    // 角
    let corner=0;
    for (const [r,c] of CORNERS){
      corner += b[r][c];
    }
    corner *= player;

    // 危険マス（角が空のときのC/Xは致命傷になりやすい）
    let danger=0;
    for (let i=0;i<4;i++){
      const [cr,cc] = CORNERS[i];
      if (b[cr][cc] !== EMPTY) continue;
      const [xr,xc] = X_SQ[i];
      danger -= 3 * b[xr][xc]; // Xは特に危険
    }
    for (const [r,c] of C_SQ){
      // Cも危険（角が空なら）
      const corner = nearestCorner(r,c);
      if (corner && b[corner.r][corner.c]===EMPTY){
        danger -= 2 * b[r][c];
      }
    }
    danger *= player;

    // モビリティ
    const myMob = getLegalMoves(b, player).length;
    const opMob = getLegalMoves(b, -player).length;
    const mob = (myMob - opMob);

    // フロンティア（空きマスに隣接している石の数：少ないほど良い）
    const frontier = (frontierCount(b, player) - frontierCount(b, -player));

    // 簡易安定度（端から連続して自色で埋まってる部分を安定寄りに評価）
    const stab = (stableEdgeApprox(b, player) - stableEdgeApprox(b, -player));

    // パリティ（終盤：空き領域の偶奇）
    const parity = parityScore(b, player);

    // 石差
    const discDiff = (black - white) * player;

    // 合成
    const score =
      wPos*pos +
      wCorner*corner +
      12*danger +
      wMob*mob +
      (-wFrontier)*frontier +
      wStab*stab +
      wParity*parity +
      wDisc*discDiff;

    // 返り値は探索に使いやすい大きさに丸める
    return score;
  }

  function lerp(a,b,t){ return a + (b-a)*t; }

  function nearestCorner(r,c){
    // 角隣接(C)用の判定（簡易）
    if (r<=1 && c<=1) return {r:0,c:0};
    if (r<=1 && c>=6) return {r:0,c:7};
    if (r>=6 && c<=1) return {r:7,c:0};
    if (r>=6 && c>=6) return {r:7,c:7};
    return null;
  }

  function frontierCount(b, player){
    let cnt=0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (b[r][c] !== player) continue;
        for (const [dr,dc] of DIRS){
          const rr=r+dr, cc=c+dc;
          if (inBounds(rr,cc) && b[rr][cc]===EMPTY){
            cnt++;
            break;
          }
        }
      }
    }
    return cnt;
  }

  function stableEdgeApprox(b, player){
    // 端から角方向に連続している石を「安定っぽい」と見なす簡易近似
    let s=0;
    // 上端
    s += stableRun(b, player, 0,0, 0,1);
    s += stableRun(b, player, 0,7, 0,-1);
    // 下端
    s += stableRun(b, player, 7,0, 0,1);
    s += stableRun(b, player, 7,7, 0,-1);
    // 左端
    s += stableRun(b, player, 0,0, 1,0);
    s += stableRun(b, player, 7,0, -1,0);
    // 右端
    s += stableRun(b, player, 0,7, 1,0);
    s += stableRun(b, player, 7,7, -1,0);
    return s;
  }
  function stableRun(b, player, r, c, dr, dc){
    let cnt=0;
    for (let i=0;i<8;i++){
      const rr=r+dr*i, cc=c+dc*i;
      if (!inBounds(rr,cc)) break;
      if (b[rr][cc]===player) cnt++;
      else break;
    }
    return cnt;
  }

  function parityScore(b, player){
    // 空きマスの連結成分ごとの偶奇（終盤用の簡易パリティ）
    // ここは軽めに：全体の空き偶奇だけでも十分効く場面がある
    const {empty} = countDiscs(b);
    return (empty % 2 === 0) ? 1 : -1;
  }

  // ====== 探索（反復深化 + αβ + TT） ======
  function isGameOver(b){
    return getLegalMoves(b, BLACK).length===0 && getLegalMoves(b, WHITE).length===0;
  }

  function terminalScore(b, player){
    const {black,white} = countDiscs(b);
    const diff = (black-white)*player;
    // 勝ち負けを強調（完全終局のときは評価より優先）
    if (diff>0) return 1e9 + diff;
    if (diff<0) return -1e9 + diff;
    return 0;
  }

  function orderMoves(b, player, moves, ttBestKey){
    // 強い並べ替え：TTの最善→角→辺→PST高→返し枚数少→危険回避
    const scored = moves.map(m => {
      const k = moveKey(m);
      let s = 0;
      if (ttBestKey !== null && k === ttBestKey) s += 1e9;

      // 角
      if ((m.r===0||m.r===7) && (m.c===0||m.c===7)) s += 5e8;

      // X/C（角が空なら避けたい）
      if (isXSquare(m.r,m.c)) s -= 2e8;
      if (isCSquare(m.r,m.c)) s -= 1e8;

      // 辺
      if (m.r===0||m.r===7||m.c===0||m.c===7) s += 2e7;

      // 位置重み（手番視点）
      s += 1e6 * PST[m.r][m.c];

      // 返す枚数は少なめが安全なことが多い（序中盤）
      s -= 2e4 * m.flips.length;

      // 1手だけ浅く見る（高速）…着手後モビリティ差
      // ただし重いのでほどほど
      const nb = cloneBoard(b);
      nb[m.r][m.c] = player;
      for (const [rr,cc] of m.flips) nb[rr][cc] = player;
      const mob = getLegalMoves(nb, player).length - getLegalMoves(nb, -player).length;
      s += 5e4 * mob;

      return {m, k, s};
    });
    scored.sort((a,b)=> b.s-a.s);
    return scored.map(x=>x.m);
  }

  function isXSquare(r,c){
    return (r===1&&c===1)||(r===1&&c===6)||(r===6&&c===1)||(r===6&&c===6);
  }
  function isCSquare(r,c){
    for (const [rr,cc] of C_SQ) if (rr===r && cc===c) return true;
    return false;
  }

  function ttGet(h){
    const k = h.toString();
    return TT.get(k) ?? null;
  }
  function ttSet(h, entry){
    const k = h.toString();
    // メモリ暴走防止：サイズが大きくなりすぎたら軽く掃除
    if (TT.size > 220000){
      // ランダムに少し削る（雑だが軽い）
      let i=0;
      for (const key of TT.keys()){
        TT.delete(key);
        if (++i>70000) break;
      }
    }
    TT.set(k, entry);
  }

  function nowMs(){ return performance.now(); }

  async function findBestMoveRoot(b, player, timeLimitMs, maxDepth){
    // 反復深化。時間を超えたら直前深さの最善を返す
    const start = nowMs();
    const deadline = start + timeLimitMs;

    let bestMove = null;
    let bestScore = -INF;
    let bestPV = [];
    let nodes = 0;

    // ルートの合法手
    let rootMoves = getLegalMoves(b, player);
    if (rootMoves.length===0) return {bestMove:null, bestScore: -INF, depth:0, nodes:0, pv:[]};

    // 初回並べ替えに TT を使う
    const tt = ttGet(hash);
    const ttBestKey = tt?.bestMoveKey ?? null;
    rootMoves = orderMoves(b, player, rootMoves, ttBestKey);

    for (let depth=1; depth<=maxDepth; depth++){
      if (nowMs() > deadline) break;

      let localBestMove = null;
      let localBestScore = -INF;
      let localBestPV = [];

      // aspiration window（軽い）
      let alpha = -INF;
      let beta  = INF;

      for (const mv of rootMoves){
        if (nowMs() > deadline) break;

        const changed = applyMoveAndHash(mv, player);
        const childHashBeforeSide = hash; // applyMoveAndHashで盤面とhashが更新済
        // 手番交代
        hash = hashToggleSide(hash);
        turn = -turn;

        const res = alphabeta(b, -player, depth-1, alpha, beta, deadline);
        nodes += res.nodes;
        const score = -res.value;

        // 元に戻す
        turn = -turn;
        hash = hashToggleSide(hash);
        undoMoveAndHash(changed);
        // childHashBeforeSide は不要

        if (score > localBestScore){
          localBestScore = score;
          localBestMove = mv;
          localBestPV = [moveKey(mv), ...res.pv];
          alpha = Math.max(alpha, score);
        }
      }

      if (localBestMove){
        bestMove = localBestMove;
        bestScore = localBestScore;
        bestPV = localBestPV;

        // 次深さの並べ替え：今回のベストを先頭に（PV move ordering）
        rootMoves = orderMoves(b, player, rootMoves, moveKey(bestMove));
      }

      // UIに負担かけない程度にyield
      await new Promise(r => setTimeout(r, 0));
    }

    // ルートTT更新
    ttSet(hash, {depth: 1, flag:0, value: bestScore, bestMoveKey: bestMove ? moveKey(bestMove) : null});

    const depthReached = bestPV.length ? bestPV.length : 0;
    return {bestMove, bestScore, depth: depthReached, nodes, pv: bestPV};
  }

  function alphabeta(b, player, depth, alpha, beta, deadline){
    let nodes = 1;

    // タイムアウト
    if (nowMs() > deadline) {
      return {value: evaluate(b, player), nodes, pv: []};
    }

    // 終局
    if (isGameOver(b)){
      return {value: terminalScore(b, player), nodes, pv: []};
    }

    // 深さ0: 静的評価（簡易qsearchを入れるならここで）
    if (depth <= 0){
      return {value: evaluate(b, player), nodes, pv: []};
    }

    // TT参照
    const entry = ttGet(hash);
    if (entry && entry.depth >= depth){
      if (entry.flag === 0) return {value: entry.value, nodes, pv: [ ...(entry.pv ?? []) ]};
      if (entry.flag === 1) alpha = Math.max(alpha, entry.value);
      else if (entry.flag === 2) beta = Math.min(beta, entry.value);
      if (alpha >= beta) return {value: entry.value, nodes, pv: []};
    }

    let moves = getLegalMoves(b, player);

    // パス
    if (moves.length === 0){
      // 手番交代だけして続行
      hash = hashToggleSide(hash);
      turn = -turn;
      const res = alphabeta(b, -player, depth-1, -beta, -alpha, deadline);
      const value = -res.value;
      turn = -turn;
      hash = hashToggleSide(hash);

      // TT保存
      ttSet(hash, {depth, flag:0, value, bestMoveKey: null});
      return {value, nodes: nodes + res.nodes, pv: res.pv};
    }

    const ttBestKey = entry?.bestMoveKey ?? null;
    moves = orderMoves(b, player, moves, ttBestKey);

    let best = -INF;
    let bestMoveKey = null;
    let bestPV = [];

    const alphaOrig = alpha;

    for (const mv of moves){
      if (nowMs() > deadline) break;

      const changed = applyMoveAndHash(mv, player);
      hash = hashToggleSide(hash);
      turn = -turn;

      const res = alphabeta(b, -player, depth-1, -beta, -alpha, deadline);
      nodes += res.nodes;
      const score = -res.value;

      turn = -turn;
      hash = hashToggleSide(hash);
      undoMoveAndHash(changed);

      if (score > best){
        best = score;
        bestMoveKey = moveKey(mv);
        bestPV = [bestMoveKey, ...res.pv];
      }
      alpha = Math.max(alpha, score);
      if (alpha >= beta) break; // βカット
    }

    // TT保存（flag付き）
    let flag = 0;
    if (best <= alphaOrig) flag = 2; // upper
    else if (best >= beta) flag = 1; // lower
    else flag = 0; // exact

    ttSet(hash, {depth, flag, value: best, bestMoveKey, pv: bestPV});

    return {value: best, nodes, pv: bestPV};
  }

  function applyMoveAndHash(mv, player){
    // 盤面変更＆hash更新（差分だけxor）
    const changed = [];
    // 置く
    changed.push([mv.r, mv.c, EMPTY, player]);
    hash = hashXorPiece(hash, mv.r, mv.c, player);
    board[mv.r][mv.c] = player;

    // 反転
    for (const [rr,cc] of mv.flips){
      const prev = board[rr][cc];
      // prev は -player のはず
      // hash: prev を消して new を足す
      hash = hashXorPiece(hash, rr, cc, prev);
      hash = hashXorPiece(hash, rr, cc, player);
      board[rr][cc] = player;
      changed.push([rr, cc, prev, player]);
    }
    return changed;
  }

  function undoMoveAndHash(changed){
    for (let i=changed.length-1;i>=0;i--){
      const [r,c,prev,now] = changed[i];
      // hash: now を消して prev を戻す
      if (now !== EMPTY) hash = hashXorPiece(hash, r, c, now);
      if (prev !== EMPTY) hash = hashXorPiece(hash, r, c, prev);
      board[r][c] = prev;
    }
  }

  // ====== 描画 ======
  function buildGrid(){
    gridEl.innerHTML = "";
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.r = String(r);
        cell.dataset.c = String(c);
        cell.addEventListener("click", onCellClick);
        gridEl.appendChild(cell);
      }
    }
  }

  function render(){
    const {black, white, empty} = countDiscs(board);
    blackCountEl.textContent = String(black);
    whiteCountEl.textContent = String(white);
    emptyCountEl.textContent = String(empty);
    turnLabel.textContent = `手番：${turn===BLACK ? "黒" : "白"}`;

    const moves = getLegalMoves(board, turn);
    const showEval = showEvalEl.checked;

    // ヒント：合法手スコア（探索で“その手の最善値”を出す）
    // ただし毎回全合法手に深探索すると重いので、
    // 1) 表示ONのときだけ
    // 2) 深さを少し抑え、TTを活用
    const hintScores = new Map(); // key "r,c" -> score
    let minS=0, maxS=0, mid=0;

    if (showEval && moves.length>0){
      const timeLimit = 180; // 表示用は軽く（ms）
      const maxDepth = Math.max(3, Math.min(7, Number(maxDepthEl.value)||7));
      const start = nowMs();
      const deadline = start + timeLimit;

      // TT best
      const tt = ttGet(hash);
      const ttBestKey = tt?.bestMoveKey ?? null;
      const ordered = orderMoves(board, turn, moves, ttBestKey);

      // ルート各手を浅めに評価（negamax）
      let scores = [];
      for (const mv of ordered){
        if (nowMs() > deadline) break;
        const changed = applyMoveAndHash(mv, turn);
        hash = hashToggleSide(hash);
        turn = -turn;

        const res = alphabeta(board, -turn, maxDepth-1, -INF, INF, deadline);
        const score = -res.value;

        turn = -turn;
        hash = hashToggleSide(hash);
        undoMoveAndHash(changed);

        hintScores.set(`${mv.r},${mv.c}`, score);
        scores.push(score);
      }

      if (scores.length){
        minS = Math.min(...scores);
        maxS = Math.max(...scores);
        mid = (minS+maxS)/2;
      }
    }

    // マス描画
    const cells = gridEl.children;
    for (let i=0;i<cells.length;i++){
      const el = cells[i];
      const r = Number(el.dataset.r);
      const c = Number(el.dataset.c);
      el.innerHTML = "";

      const v = board[r][c];
      if (v !== EMPTY){
        const disc = document.createElement("div");
        disc.className = "disc " + (v===BLACK ? "black" : "white");
        el.appendChild(disc);
      }

      const key = `${r},${c}`;
      if (hintScores.has(key)){
        const sc = hintScores.get(key);
        const hint = document.createElement("div");
        const cls = (maxS===minS) ? "neutral" : (sc >= mid ? "good" : "bad");
        hint.className = "hint " + cls;
        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = fmt(sc);
        hint.appendChild(badge);
        el.appendChild(hint);
      }
    }

    // ログ
    if (moves.length===0){
      debugEl.textContent = "合法手がありません。パスしてください。";
    } else {
      debugEl.textContent =
        `合法手: ${moves.length}\n` +
        `TT size: ${TT.size}\n` +
        `AI: ${aiSideEl.value}, think=${Number(thinkMsEl.value)||800}ms, maxDepth=${Number(maxDepthEl.value)||11}\n` +
        `表示用評価: ${showEvalEl.checked ? "ON" : "OFF"}（ONのときは浅探索で各手を採点）`;
    }
  }

  function fmt(x){
    // 大きい値も見やすく
    const v = Math.round(x);
    if (v >= 100000000) return "∞";
    if (v <= -100000000) return "-∞";
    return String(v);
  }

  function pushHistory(){
    history.push({board: cloneBoard(board), turn, hash});
    // 連打で溜まりすぎないように上限
    if (history.length > 200) history.shift();
  }

  // ====== クリック処理 ======
  function onCellClick(e){
    if (thinking) return;

    const r = Number(e.currentTarget.dataset.r);
    const c = Number(e.currentTarget.dataset.c);

    // AIの番なら人間クリックは無効（混乱防止）
    const aiSide = getAISide();
    if (aiSide !== null && turn === aiSide) return;

    const moves = getLegalMoves(board, turn);
    const mv = moves.find(m => m.r===r && m.c===c);
    if (!mv) return;

    pushHistory();
    // 盤面とhashを適切に更新（applyMoveAndHashを使う）
    applyMoveAndHash(mv, turn);
    // 手番交代
    hash = hashToggleSide(hash);
    turn = -turn;

    render();
    maybeAutoAIMove();
  }

  function getAISide(){
    const v = aiSideEl.value;
    if (v==="BLACK") return BLACK;
    if (v==="WHITE") return WHITE;
    return null;
  }

  function maybeAutoAIMove(){
    // 自動でAIが打つ
    void doAIMoveIfNeeded(false);
  }

  async function doAIMoveIfNeeded(force){
    const aiSide = getAISide();
    if (aiSide === null) return;
    if (!force && turn !== aiSide) return;
    if (thinking) return;

    const moves = getLegalMoves(board, turn);
    if (moves.length === 0){
      flashDebug("AIの手番ですが合法手がありません。パスしてください。");
      return;
    }

    thinking = true;
    aiMoveBtn.textContent = "AI思考中…";
    aiMoveBtn.disabled = true;
    try{
      const timeLimit = clamp(Number(thinkMsEl.value)||800, 50, 5000);
      const maxDepth = clamp(Number(maxDepthEl.value)||11, 2, 20);

      const startInfo = countDiscs(board);
      flashDebug(`AI思考開始（空き=${startInfo.empty}）…`);

      const res = await findBestMoveRoot(board, turn, timeLimit, maxDepth);

      if (!res.bestMove){
        flashDebug("AIが手を選べませんでした（異常）。");
        thinking = false;
        aiMoveBtn.textContent = "AIに1手打たせる";
        aiMoveBtn.disabled = false;
        return;
      }

      pushHistory();
      applyMoveAndHash(res.bestMove, turn);
      hash = hashToggleSide(hash);
      turn = -turn;

      // ログ
      const rc = `(${res.bestMove.r+1},${res.bestMove.c+1})`;
      debugEl.textContent =
        `AI着手: ${rc}\n` +
        `score: ${fmt(res.bestScore)}\n` +
        `nodes: ${res.nodes}\n` +
        `pv: ${res.pv.map(k => {
          const {r,c}=keyToRC(k);
          return `(${r+1},${c+1})`;
        }).join(" ")}`;

      render();
    } finally {
      thinking = false;
      aiMoveBtn.textContent = "AIに1手打たせる";
      aiMoveBtn.disabled = false;
      // 連続でAI同士になる場合（両方AI設定はUIにないけど）に備え
    }
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  let flashTimer=null;
  function flashDebug(msg){
    debugEl.textContent = msg;
    if (flashTimer) clearTimeout(flashTimer);
    flashTimer=setTimeout(()=>render(), 900);
  }
})();
</script>
</body>
</html>
