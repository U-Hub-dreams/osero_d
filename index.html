// worker.js (Web Worker)
// Bitboard + αβ探索 + 反復深化(Iterative Deepening) + 置換表(Transposition Table)
// 「時間制限なし」= 深さを空きマス数まで伸ばして“終局まで”探索する方針。
// ただし局面によっては非常に時間がかかるので、途中経過(best so far)を随時postする。

const BLACK = 0;
const WHITE = 1;

let stopFlag = false;

// 方向ごとのシフト用マスク（端での巻き込み防止）
const FILE_A = 0x0101010101010101n;
const FILE_H = 0x8080808080808080n;
const NOT_A  = 0xfefefefefefefefen;
const NOT_H  = 0x7f7f7f7f7f7f7f7fn;
const FULL   = 0xffffffffffffffffn;

function popcount(x){
  let c = 0;
  while (x) { x &= (x - 1n); c++; }
  return c;
}

// index: 0(A1) .. 63(H8) ; row-major
function bit(i){ return 1n << BigInt(i); }

function indexToCoord(i){
  const r = Math.floor(i/8);
  const c = i%8;
  return [r,c];
}

function coordToIndex(r,c){ return r*8+c; }

/**
 * 8方向のシフト
 * board bits: A1 is LSB (bit0)
 * East: +1, West:-1, South:+8, North:-8
 * NE: -7, NW:-9, SE:+9, SW:+7
 */
function shiftE(x){ return (x & NOT_H) << 1n; }
function shiftW(x){ return (x & NOT_A) >> 1n; }
function shiftS(x){ return (x) << 8n; }
function shiftN(x){ return (x) >> 8n; }
function shiftSE(x){ return (x & NOT_H) << 9n; }
function shiftSW(x){ return (x & NOT_A) << 7n; }
function shiftNE(x){ return (x & NOT_H) >> 7n; }
function shiftNW(x){ return (x & NOT_A) >> 9n; }

const SHIFTS = [
  shiftN, shiftS, shiftE, shiftW, shiftNE, shiftNW, shiftSE, shiftSW
];

function getPlayerBoards(black, white, turn){
  return (turn === BLACK) ? [black, white] : [white, black];
}

/**
 * legal moves bitmask for current player
 * Standard bitboard method:
 *  For each direction:
 *    t = shift(P) & O
 *    repeat: t |= shift(t) & O
 *    moves |= shift(t) & empty
 */
function legalMoves(black, white, turn){
  const occ = black | white;
  const empty = (~occ) & FULL;
  let P, O;
  [P, O] = getPlayerBoards(black, white, turn);

  let moves = 0n;
  for (const sh of SHIFTS){
    let t = sh(P) & O;
    // expand up to 6 times (max chain length)
    for (let i=0;i<6;i++){
      t |= sh(t) & O;
    }
    moves |= sh(t) & empty;
  }
  return moves;
}

/**
 * apply moveIndex for current player and return new (black, white, nextTurn)
 */
function applyMove(black, white, turn, moveIndex){
  const m = bit(moveIndex);
  const occ = black | white;
  if (occ & m) return null;

  let P, O;
  [P, O] = getPlayerBoards(black, white, turn);

  let flips = 0n;
  for (const sh of SHIFTS){
    let x = 0n;
    let t = sh(m);
    // 連続する相手石を集める
    while (t && (t & O)){
      x |= t;
      t = sh(t);
    }
    // その先が自分の石なら挟める
    if (t & P){
      flips |= x;
    }
  }
  if (!flips) return null; // illegal

  P = P | m | flips;
  O = O & (~flips);

  if (turn === BLACK){
    black = P; white = O;
  } else {
    white = P; black = O;
  }

  // 次手番（パス判定は呼び出し側でもOKだが、ここで処理する）
  const nextTurn = 1 - turn;
  return { black, white, turn: nextTurn };
}

function movesToArray(mask){
  const arr = [];
  while (mask){
    const lsb = mask & -mask;
    const idx = Number(BigInt.asUintN(64, log2(lsb)));
    arr.push(idx);
    mask ^= lsb;
  }
  return arr;
}

// BigInt log2 for power-of-two: find index of set bit
function log2(p2){
  // p2 is power of two
  let i = 0n;
  while ((p2 >> i) > 1n) i++;
  return i;
}

// Move ordering: corners first, then mobility-ish
const CORNERS = [0,7,56,63];
const cornerMask = bit(0) | bit(7) | bit(56) | bit(63);

// Simple static ordering score
function moveOrderScore(i){
  if (i === 0 || i === 7 || i === 56 || i === 63) return 1000;
  // edges
  const r = Math.floor(i/8), c = i%8;
  if (r===0||r===7||c===0||c===7) return 50;
  // avoid X-squares (danger near corners)
  const xSquares = new Set([9,14,49,54]);
  if (xSquares.has(i)) return -80;
  return 0;
}

/**
 * Negamax with alpha-beta
 * score: 最終的な (手番プレイヤー視点) の石差
 *  - 終局: (Pcount - Ocount)
 *  - パスや両者パスで終局
 */
const TT = new Map(); // key -> { depth, flag, value, bestMove }
const TT_MAX = 2_000_000; // メモリを食いすぎない程度（状況により調整）

const FLAG_EXACT = 0;
const FLAG_LOWER = 1;
const FLAG_UPPER = 2;

function ttKey(black, white, turn){
  // 盤面2枚+turnでキー（文字列でも良いが、BigInt合成）
  // (black << 65) | (white << 1) | turn
  // ただしBigIntは巨大になるので文字列キーにする（Worker内なのでOK）
  return black.toString(16) + "|" + white.toString(16) + "|" + turn;
}

function gameOver(black, white){
  const occ = black | white;
  return occ === FULL;
}

function finalScore(black, white, turn){
  const b = popcount(black);
  const w = popcount(white);
  const diff = b - w;
  // negamaxの都合で「手番側視点」に合わせる
  return (turn === BLACK) ? diff : -diff;
}

function negamax(black, white, turn, depth, alpha, beta, pvOut){
  if (stopFlag) return { value: 0, bestMove: null, pv: [] };

  const key = ttKey(black, white, turn);
  const alphaOrig = alpha;

  const tt = TT.get(key);
  if (tt && tt.depth >= depth){
    if (tt.flag === FLAG_EXACT) return { value: tt.value, bestMove: tt.bestMove ?? null, pv: [] };
    if (tt.flag === FLAG_LOWER) alpha = Math.max(alpha, tt.value);
    else if (tt.flag === FLAG_UPPER) beta = Math.min(beta, tt.value);
    if (alpha >= beta) return { value: tt.value, bestMove: tt.bestMove ?? null, pv: [] };
  }

  const occ = black | white;
  const empties = 64 - popcount(occ);

  // 終局（盤が埋まった） or 深さ0: ここでは「深さ0」でも完全探索が目的なので評価を石差で返す
  if (empties === 0 || depth === 0){
    return { value: finalScore(black, white, turn), bestMove: null, pv: [] };
  }

  let moves = legalMoves(black, white, turn);

  // パス処理
  if (moves === 0n){
    const oppMoves = legalMoves(black, white, 1 - turn);
    if (oppMoves === 0n){
      // 両者パス=終局
      return { value: finalScore(black, white, turn), bestMove: null, pv: [] };
    }
    // 自分パス：手番交代（価値は符号反転）
    const child = negamax(black, white, 1 - turn, depth - 1, -beta, -alpha, pvOut);
    return { value: -child.value, bestMove: null, pv: [] };
  }

  // move ordering
  let moveList = movesToArray(moves);
  moveList.sort((a,b)=> moveOrderScore(b) - moveOrderScore(a));

  // TT bestMove を先頭へ
  if (tt && tt.bestMove !== undefined && tt.bestMove !== null){
    const bm = tt.bestMove;
    const idx = moveList.indexOf(bm);
    if (idx > 0){
      moveList.splice(idx,1);
      moveList.unshift(bm);
    }
  }

  let bestVal = -Infinity;
  let bestMove = null;
  let bestPv = [];

  for (const m of moveList){
    const next = applyMove(black, white, turn, m);
    if (!next) continue;

    const child = negamax(next.black, next.white, next.turn, depth - 1, -beta, -alpha, pvOut);
    const val = -child.value;

    if (val > bestVal){
      bestVal = val;
      bestMove = m;
      bestPv = [m, ...child.pv];
    }
    alpha = Math.max(alpha, val);
    if (alpha >= beta) break; // cutoff
    if (stopFlag) break;
  }

  // store TT
  if (TT.size > TT_MAX){
    // 雑にクリア（本気でやるならLRUなど。ここはシンプル優先）
    TT.clear();
  }
  let flag = FLAG_EXACT;
  if (bestVal <= alphaOrig) flag = FLAG_UPPER;
  else if (bestVal >= beta) flag = FLAG_LOWER;

  TT.set(key, { depth, flag, value: bestVal, bestMove });

  return { value: bestVal, bestMove, pv: bestPv };
}

let nodes = 0;

// nodes を正確に数えるために negamax をラップ
function negamaxCount(black, white, turn, depth, alpha, beta){
  nodes++;
  return negamax(black, white, turn, depth, alpha, beta, null);
}

function iterativeDeepeningSearch(black, white, turn){
  stopFlag = false;
  nodes = 0;

  const occ = black | white;
  const empties = 64 - popcount(occ);

  // 最大深さ＝空きマス数（終局まで）
  const maxDepth = empties;

  let bestMove = null;
  let bestScore = 0;

  // 反復深化：d=1..maxDepth
  for (let d=1; d<=maxDepth; d++){
    if (stopFlag) break;

    const res = negamaxCount(black, white, turn, d, -9999, 9999);
    if (stopFlag) break;

    if (res.bestMove !== null){
      bestMove = res.bestMove;
      bestScore = res.value;
    }

    postMessage({
      type: "info",
      bestMove,
      depth: d,
      score: bestScore,
      nodes,
      pv: (res.pv ?? []).slice(0, 12) // 表示は短く
    });
  }

  postMessage({
    type: "done",
    bestMove,
    depth: stopFlag ? "stopped" : maxDepth,
    score: bestScore,
    nodes
  });
}

onmessage = (ev)=>{
  const msg = ev.data;
  if (!msg || !msg.type) return;

  if (msg.type === "stop"){
    stopFlag = true;
    return;
  }

  if (msg.type === "legal"){
    const mask = legalMoves(BigInt(msg.black), BigInt(msg.white), msg.turn);
    postMessage({ type: "legalResult", mask: mask.toString() });
    return;
  }

  if (msg.type === "play"){
    const black = BigInt(msg.black);
    const white = BigInt(msg.white);
    const turn = msg.turn;
    const moveIndex = msg.moveIndex;

    const next = applyMove(black, white, turn, moveIndex);
    if (!next){
      postMessage({ type: "nomove" });
      return;
    }

    // パスの自動処理（次番が打てないならもう一度交代）
    let nb = next.black, nw = next.white, nt = next.turn;
    const lm = legalMoves(nb, nw, nt);
    if (lm === 0n){
      const opp = legalMoves(nb, nw, 1-nt);
      if (opp !== 0n){
        nt = 1-nt;
      }
    }

    postMessage({ type: "played", black: nb.toString(), white: nw.toString(), turn: nt, moveIndex });
    return;
  }

  if (msg.type === "search"){
    const black = BigInt(msg.black);
    const white = BigInt(msg.white);
    const turn = msg.turn;

    // 置換表は局面が変わると役に立つので残すが、気になるならクリアでもOK
    // TT.clear();

    iterativeDeepeningSearch(black, white, turn);
    return;
  }
};
