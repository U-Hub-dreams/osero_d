<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Webオセロ（合法手に評価値表示）</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1b34;
      --board:#0b3f2a;
      --cell:#0e5639;
      --grid:#0a2f1f;
      --text:#e6eefc;
      --muted:#9fb1d6;
      --accent:#60a5fa;
      --good:#34d399;
      --bad:#fb7185;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 0%, #14224a 0%, var(--bg) 60%);
      color:var(--text);
    }
    .wrap{
      max-width: 1100px;
      margin: 20px auto;
      padding: 16px;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:16px;
    }
    @media (max-width: 900px){
      .wrap{grid-template-columns:1fr}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border:1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .title{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .title h1{
      font-size: 18px;
      margin:0;
      letter-spacing: .02em;
    }
    .title .sub{
      font-size: 12px;
      color: var(--muted);
    }
    .board{
      width: min(70vh, 620px);
      aspect-ratio: 1 / 1;
      margin: 0 auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border-radius: 18px;
      padding: 12px;
      border:1px solid rgba(255,255,255,0.12);
    }
    .grid{
      width:100%;
      height:100%;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: 6px;
      background: var(--grid);
      padding: 6px;
      border-radius: 14px;
    }
    .cell{
      position:relative;
      border-radius: 12px;
      background: radial-gradient(140px 140px at 20% 20%, rgba(255,255,255,0.12), rgba(255,255,255,0.02)), linear-gradient(180deg, #0f6b47, var(--cell));
      border:1px solid rgba(0,0,0,0.25);
      cursor:pointer;
      user-select:none;
      overflow:hidden;
    }
    .cell:hover{
      outline: 2px solid rgba(96,165,250,0.45);
      outline-offset: -2px;
    }
    .disc{
      position:absolute;
      inset: 12%;
      border-radius:999px;
      box-shadow: 0 10px 16px rgba(0,0,0,0.35);
      transform: translateZ(0);
    }
    .black{
      background: radial-gradient(140px 140px at 30% 25%, #3b3b3b 0%, #0c0c0c 55%, #000 100%);
    }
    .white{
      background: radial-gradient(140px 140px at 30% 25%, #ffffff 0%, #e6e6e6 55%, #cfcfcf 100%);
    }
    .hint{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 13px;
      font-weight: 800;
      letter-spacing: .02em;
      text-shadow: 0 2px 10px rgba(0,0,0,0.55);
      pointer-events:none;
    }
    .hint .badge{
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(15, 27, 52, 0.72);
      border: 1px solid rgba(255,255,255,0.14);
      min-width: 52px;
      text-align:center;
      backdrop-filter: blur(4px);
    }
    .hint.good .badge{ color: var(--good); }
    .hint.bad .badge{ color: var(--bad); }

    .right .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(15,27,52,0.55);
      border:1px solid rgba(255,255,255,0.10);
      color: var(--text);
      font-size: 13px;
    }
    .dot{
      width:10px;height:10px;border-radius:99px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(96,165,250,0.18);
    }
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{
      cursor:pointer;
      border:none;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(96,165,250,0.18);
      color: var(--text);
      border: 1px solid rgba(96,165,250,0.35);
      font-weight: 700;
      letter-spacing: .01em;
    }
    button:hover{background: rgba(96,165,250,0.28)}
    button:active{transform: translateY(1px)}
    .small{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.55;
    }
    .kv{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
    }
    .kv .box{
      padding: 10px;
      border-radius: 14px;
      background: rgba(15,27,52,0.45);
      border:1px solid rgba(255,255,255,0.10);
    }
    .box h3{
      margin:0 0 6px 0;
      font-size: 13px;
      color: #cfe0ff;
      letter-spacing: .02em;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      color: #d7e3ff;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(15,27,52,0.45);
      border:1px solid rgba(255,255,255,0.10);
      font-size: 13px;
    }
    input[type="checkbox"]{transform: scale(1.1)}
    select{
      background: rgba(15,27,52,0.65);
      color: var(--text);
      border:1px solid rgba(255,255,255,0.14);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="title">
        <h1>Webオセロ：合法手に評価値を表示</h1>
        <div class="sub">クリックで着手（黒→白→…）</div>
      </div>

      <div class="board">
        <div id="grid" class="grid" aria-label="Othello board"></div>
      </div>

      <div class="small" style="margin-top:10px;">
        表示している数値は「その手を打った直後の盤面」を、簡易評価関数で採点したものです（大きいほど良い）。
      </div>
    </div>

    <div class="card right">
      <div class="row">
        <span class="pill"><span class="dot"></span><span id="turnLabel">手番：黒</span></span>
        <span class="pill">黒 <b id="blackCount">2</b> / 白 <b id="whiteCount">2</b></span>
      </div>

      <div class="row">
        <label class="toggle">
          <input id="showEval" type="checkbox" checked />
          合法手の評価値を表示
        </label>

        <label class="toggle">
          <span style="opacity:.9;">評価方式</span>
          <select id="evalMode">
            <option value="balanced" selected>バランス</option>
            <option value="mobility">モビリティ重視</option>
            <option value="positional">位置重視</option>
          </select>
        </label>
      </div>

      <div class="btns">
        <button id="undoBtn">1手戻す</button>
        <button id="resetBtn">初期化</button>
        <button id="passBtn">パス（手が無い時）</button>
      </div>

      <div class="kv">
        <div class="box">
          <h3>この評価で見ているもの</h3>
          <div class="small">
            ・位置重み（角・辺の価値）<br/>
            ・モビリティ（次の合法手数）<br/>
            ・角取得ボーナス / 角隣接ペナルティ<br/>
            ・石差（控えめ）<br/>
            ※「強いAI」の完全版は探索（ミニマックス＋αβ）もしますが、ここでは“競技AIでよく見る要素”を点数化しています。
          </div>
        </div>

        <div class="box">
          <h3>デバッグ表示</h3>
          <div id="debug" class="mono"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== 定数 ======
  const N = 8;
  const EMPTY = 0, BLACK = 1, WHITE = -1;

  // 競技AIで定番の「位置重み」系（簡易）
  // 角が高く、角の隣（C/X）が低い、辺がそこそこ…という典型形
  const WEIGHTS = [
    [120,-20, 20,  5,  5, 20,-20,120],
    [-20,-40, -5, -5, -5, -5,-40,-20],
    [ 20, -5, 15,  3,  3, 15, -5, 20],
    [  5, -5,  3,  3,  3,  3, -5,  5],
    [  5, -5,  3,  3,  3,  3, -5,  5],
    [ 20, -5, 15,  3,  3, 15, -5, 20],
    [-20,-40, -5, -5, -5, -5,-40,-20],
    [120,-20, 20,  5,  5, 20,-20,120],
  ];

  const DIRS = [
    [-1,-1],[-1,0],[-1,1],
    [ 0,-1],       [ 0,1],
    [ 1,-1],[ 1,0],[ 1,1],
  ];

  // 評価係数（モードで切替）
  const COEFF = {
    balanced:   { pos: 1.0, mob: 12.0, corner: 25.0, cornerAdj: 18.0, disc: 1.0 },
    mobility:   { pos: 0.7, mob: 18.0, corner: 22.0, cornerAdj: 16.0, disc: 0.7 },
    positional: { pos: 1.2, mob:  9.0, corner: 28.0, cornerAdj: 20.0, disc: 0.9 },
  };

  // 角と、その隣接（C/X）座標
  const CORNERS = [[0,0],[0,7],[7,0],[7,7]];
  const CORNER_ADJ = new Map([
    ["0,0",  [[0,1],[1,0],[1,1]]],
    ["0,7",  [[0,6],[1,7],[1,6]]],
    ["7,0",  [[6,0],[7,1],[6,1]]],
    ["7,7",  [[6,7],[7,6],[6,6]]],
  ]);

  // ====== 状態 ======
  let board = makeEmptyBoard();
  let turn = BLACK;
  let history = []; // undo用（盤面スナップショット）

  // UI
  const gridEl = document.getElementById("grid");
  const turnLabel = document.getElementById("turnLabel");
  const blackCountEl = document.getElementById("blackCount");
  const whiteCountEl = document.getElementById("whiteCount");
  const debugEl = document.getElementById("debug");
  const showEvalEl = document.getElementById("showEval");
  const evalModeEl = document.getElementById("evalMode");
  const undoBtn = document.getElementById("undoBtn");
  const resetBtn = document.getElementById("resetBtn");
  const passBtn = document.getElementById("passBtn");

  // ====== 初期化 ======
  initBoard(board);
  buildGrid();
  render();

  // ====== イベント ======
  showEvalEl.addEventListener("change", render);
  evalModeEl.addEventListener("change", render);

  undoBtn.addEventListener("click", () => {
    if (history.length === 0) return;
    const prev = history.pop();
    board = prev.board;
    turn = prev.turn;
    render();
  });

  resetBtn.addEventListener("click", () => {
    board = makeEmptyBoard();
    initBoard(board);
    turn = BLACK;
    history = [];
    render();
  });

  passBtn.addEventListener("click", () => {
    const moves = getLegalMoves(board, turn);
    if (moves.length > 0) {
      flashDebug("まだ合法手があります。パスは不要です。");
      return;
    }
    history.push({ board: cloneBoard(board), turn });
    turn = -turn;
    render();
  });

  // ====== 盤面・合法手 ======
  function makeEmptyBoard(){
    return Array.from({length:N}, () => Array(N).fill(EMPTY));
  }
  function cloneBoard(b){
    return b.map(row => row.slice());
  }
  function initBoard(b){
    // 標準初期配置
    b[3][3] = WHITE;
    b[3][4] = BLACK;
    b[4][3] = BLACK;
    b[4][4] = WHITE;
  }
  function inBounds(r,c){ return r>=0 && r<N && c>=0 && c<N; }

  function getFlips(b, r, c, player){
    if (b[r][c] !== EMPTY) return [];
    const opp = -player;
    let flips = [];

    for (const [dr,dc] of DIRS){
      let rr = r + dr, cc = c + dc;
      let line = [];
      while (inBounds(rr,cc) && b[rr][cc] === opp){
        line.push([rr,cc]);
        rr += dr; cc += dc;
      }
      if (line.length > 0 && inBounds(rr,cc) && b[rr][cc] === player){
        flips = flips.concat(line);
      }
    }
    return flips;
  }

  function getLegalMoves(b, player){
    const moves = [];
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const flips = getFlips(b,r,c,player);
        if (flips.length > 0) moves.push({r,c,flips});
      }
    }
    return moves;
  }

  function applyMove(b, move, player){
    const nb = cloneBoard(b);
    nb[move.r][move.c] = player;
    for (const [rr,cc] of move.flips) nb[rr][cc] = player;
    return nb;
  }

  // ====== 評価関数（合法手に表示する値） ======
  function evaluateBoard(b, player, modeKey){
    // player 視点で大きいほど良い
    const k = COEFF[modeKey] ?? COEFF.balanced;

    const counts = countDiscs(b);
    const discDiff = (counts.black - counts.white) * player; // player視点
    const discTerm = k.disc * discDiff;

    // 位置重み合計
    let posSum = 0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        posSum += WEIGHTS[r][c] * b[r][c] * player; // player視点に寄せる
      }
    }
    const posTerm = k.pos * posSum;

    // モビリティ：自分の合法手 - 相手の合法手
    const myMob = getLegalMoves(b, player).length;
    const opMob = getLegalMoves(b, -player).length;
    const mobTerm = k.mob * (myMob - opMob);

    // 角：自分の角 - 相手の角
    let myCorner = 0, opCorner = 0;
    for (const [r,c] of CORNERS){
      if (b[r][c] === player) myCorner++;
      else if (b[r][c] === -player) opCorner++;
    }
    const cornerTerm = k.corner * (myCorner - opCorner);

    // 角の隣（C/X）：角が空いてる時に隣に置くのは危険…をペナルティ化
    // 「自分が角隣接を持つほどマイナス」「相手が持つほどプラス」
    let adjScore = 0;
    for (const [cr,cc] of CORNERS){
      if (b[cr][cc] !== EMPTY) continue; // 角が埋まってたら危険度が変わるので簡略化して無視
      const key = `${cr},${cc}`;
      for (const [ar,ac] of (CORNER_ADJ.get(key) ?? [])){
        if (b[ar][ac] === player) adjScore -= 1;
        else if (b[ar][ac] === -player) adjScore += 1;
      }
    }
    const cornerAdjTerm = k.cornerAdj * adjScore;

    const total = posTerm + mobTerm + cornerTerm + cornerAdjTerm + discTerm;

    return {
      total,
      parts: { posTerm, mobTerm, cornerTerm, cornerAdjTerm, discTerm, myMob, opMob, discDiff, myCorner, opCorner }
    };
  }

  // ====== 描画 ======
  function buildGrid(){
    gridEl.innerHTML = "";
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.r = String(r);
        cell.dataset.c = String(c);
        cell.addEventListener("click", onCellClick);
        gridEl.appendChild(cell);
      }
    }
  }

  function render(){
    // カウント
    const counts = countDiscs(board);
    blackCountEl.textContent = String(counts.black);
    whiteCountEl.textContent = String(counts.white);
    turnLabel.textContent = `手番：${turn === BLACK ? "黒" : "白"}`;

    // 合法手
    const moves = getLegalMoves(board, turn);
    const showEval = showEvalEl.checked;
    const modeKey = evalModeEl.value;

    // 合法手に対し、着手後盤面を評価
    const evalMap = new Map(); // "r,c" -> {score, detail}
    if (showEval){
      for (const mv of moves){
        const nb = applyMove(board, mv, turn);
        const ev = evaluateBoard(nb, turn, modeKey); // turn視点
        evalMap.set(`${mv.r},${mv.c}`, ev);
      }
    }

    // 正規化して色分け（良い/悪い）
    let scores = [];
    for (const v of evalMap.values()) scores.push(v.total);
    const minS = scores.length ? Math.min(...scores) : 0;
    const maxS = scores.length ? Math.max(...scores) : 0;
    const mid = (minS + maxS) / 2;

    // 盤面描画
    const cells = gridEl.children;
    for (let i=0;i<cells.length;i++){
      const el = cells[i];
      const r = Number(el.dataset.r);
      const c = Number(el.dataset.c);
      el.innerHTML = "";

      const v = board[r][c];
      if (v !== EMPTY){
        const disc = document.createElement("div");
        disc.className = "disc " + (v === BLACK ? "black" : "white");
        el.appendChild(disc);
      }

      // 評価表示（合法手のみ）
      const key = `${r},${c}`;
      if (evalMap.has(key)){
        const ev = evalMap.get(key);
        const hint = document.createElement("div");
        const isGood = (ev.total >= mid);
        hint.className = "hint " + (isGood ? "good" : "bad");
        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = formatScore(ev.total);
        hint.appendChild(badge);
        el.appendChild(hint);
      }
    }

    // デバッグ：最善手など
    if (moves.length === 0){
      debugEl.textContent = "合法手がありません。パスしてください。";
      return;
    }
    if (!showEval){
      debugEl.textContent = `合法手: ${moves.length} 手（評価表示OFF）`;
      return;
    }

    // ベストを表示
    let bestKey = null, bestEv = null;
    for (const [k, ev] of evalMap.entries()){
      if (!bestEv || ev.total > bestEv.total){
        bestEv = ev; bestKey = k;
      }
    }
    const [br, bc] = bestKey.split(",").map(Number);
    debugEl.textContent =
      `合法手: ${moves.length} 手 / 評価方式: ${modeKey}\n` +
      `最善(推定): (${br+1},${bc+1})  score=${formatScore(bestEv.total)}\n` +
      `内訳: pos=${formatScore(bestEv.parts.posTerm)}  mob=${formatScore(bestEv.parts.mobTerm)}\n` +
      `      corner=${formatScore(bestEv.parts.cornerTerm)}  adj=${formatScore(bestEv.parts.cornerAdjTerm)}\n` +
      `      disc=${formatScore(bestEv.parts.discTerm)}  (discDiff=${bestEv.parts.discDiff}, myMob=${bestEv.parts.myMob}, opMob=${bestEv.parts.opMob})`;
  }

  function onCellClick(e){
    const r = Number(e.currentTarget.dataset.r);
    const c = Number(e.currentTarget.dataset.c);

    const moves = getLegalMoves(board, turn);
    const mv = moves.find(m => m.r === r && m.c === c);
    if (!mv) return;

    history.push({ board: cloneBoard(board), turn });
    board = applyMove(board, mv, turn);
    turn = -turn;

    // 次手番に合法手が無ければ（簡易）メッセージだけ出す
    const nextMoves = getLegalMoves(board, turn);
    if (nextMoves.length === 0){
      flashDebug("次の手番に合法手がありません。必要ならパスしてください。");
    }
    render();
  }

  function countDiscs(b){
    let black=0, white=0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (b[r][c] === BLACK) black++;
        else if (b[r][c] === WHITE) white++;
      }
    }
    return {black, white};
  }

  function formatScore(x){
    // 見た目優先：小数1桁
    const v = Math.round(x * 10) / 10;
    // -0 を 0 に
    return (Object.is(v, -0) ? 0 : v).toFixed(1);
  }

  let flashTimer = null;
  function flashDebug(msg){
    debugEl.textContent = msg;
    if (flashTimer) clearTimeout(flashTimer);
    flashTimer = setTimeout(() => render(), 900);
  }
})();
</script>
</body>
</html>
