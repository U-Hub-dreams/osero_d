<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Othello Eval Board</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#101a2e;
      --board:#0a6a3a;
      --grid:#0f3d2a;
      --text:#e8eefc;
      --muted:#a9b7d6;
      --accent:#7aa2ff;
      --warn:#ffcc66;
      --best:#ff5ea8;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", Arial;
      background: linear-gradient(180deg, #070b14, var(--bg));
      color:var(--text);
    }
    header{
      padding:18px 16px 8px;
      max-width:980px;
      margin:0 auto;
    }
    h1{
      margin:0 0 8px;
      font-size:18px;
      font-weight:700;
      letter-spacing:.2px;
    }
    .sub{
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
    }
    .wrap{
      max-width:980px;
      margin:0 auto;
      padding:10px 16px 24px;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:14px;
    }
    @media (max-width: 880px){
      .wrap{grid-template-columns:1fr; }
    }
    .card{
      background: rgba(16,26,46,.92);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .boardWrap{ padding:14px; }
    .board{
      width:100%;
      aspect-ratio: 1 / 1;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      background: var(--board);
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .cell{
      position:relative;
      border:1px solid rgba(15,61,42,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      cursor:pointer;
      background: rgba(0,0,0,.04);
    }
    .cell:hover{ outline:2px solid rgba(122,162,255,.35); outline-offset:-2px; }
    .disc{
      width:74%;
      height:74%;
      border-radius:999px;
      box-shadow: inset 0 2px 6px rgba(255,255,255,.16), 0 8px 18px rgba(0,0,0,.35);
    }
    .black{ background: radial-gradient(circle at 30% 30%, #3a3a3a, #0b0b0b 65%); }
    .white{ background: radial-gradient(circle at 30% 30%, #ffffff, #d9d9d9 65%); }
    .eval{
      position:absolute;
      bottom:6px;
      right:6px;
      font-size:12px;
      font-weight:700;
      letter-spacing:.2px;
      padding:2px 6px;
      border-radius:999px;
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      color:var(--text);
      backdrop-filter: blur(6px);
    }
    .eval.muted{
      color: rgba(232,238,252,.62);
      background: rgba(0,0,0,.20);
      border-color: rgba(255,255,255,.08);
    }
    .badge{
      position:absolute;
      top:6px;
      left:6px;
      font-size:10px;
      font-weight:800;
      padding:2px 6px;
      border-radius:999px;
      background: rgba(0,0,0,.32);
      border:1px solid rgba(255,255,255,.10);
      color: rgba(232,238,252,.80);
    }
    .legalDot{
      position:absolute;
      width:12px;
      height:12px;
      border-radius:999px;
      background: rgba(255,255,255,.45);
      box-shadow: 0 0 0 3px rgba(0,0,0,.15);
      top:10px;
      right:10px;
    }
    .best{
      outline:3px solid rgba(255,94,168,.70) !important;
      outline-offset:-3px;
      box-shadow: inset 0 0 0 999px rgba(255,94,168,.06);
    }
    .side{
      padding:14px;
    }
    .row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    button{
      background: rgba(122,162,255,.16);
      color:var(--text);
      border:1px solid rgba(122,162,255,.35);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      transition:.12s ease;
    }
    button:hover{ transform: translateY(-1px); background: rgba(122,162,255,.22); }
    button:active{ transform: translateY(0px); }
    button.secondary{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.14);
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      margin-bottom:10px;
    }
    input[type="checkbox"]{ width:18px; height:18px; }
    .stat{
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px 12px;
      margin-top:10px;
      line-height:1.55;
      font-size:13px;
      color: rgba(232,238,252,.88);
    }
    .k{
      color: rgba(232,238,252,.62);
      font-weight:700;
      font-size:12px;
    }
    .v{
      font-weight:800;
      font-size:14px;
      margin-left:6px;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .note{
      margin-top:10px;
      color: rgba(232,238,252,.62);
      font-size:12px;
      line-height:1.5;
    }
    .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:8px;
      font-size:12px;
      color: rgba(232,238,252,.70);
    }
    .pill{
      padding:4px 8px;
      border-radius:999px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
    }
  </style>
</head>
<body>
<header>
  <h1>オセロ：各マスの評価値を常時表示（手の評価つき）</h1>
  <div class="sub">
    空マスは「位置の基本評価」を表示。合法手のマスは「その手を打った場合の評価」を表示します（基本 + 返せる枚数 + 相手の合法手を減らす効果）。<br/>
    ※評価は“強さの目安”のヒューリスティックです（完全読みではありません）。
  </div>
</header>

<div class="wrap">
  <div class="card boardWrap">
    <div id="board" class="board" aria-label="othello board"></div>
    <div class="legend">
      <span class="pill">右下の数値：評価</span>
      <span class="pill">白い点：合法手</span>
      <span class="pill">ピンク枠：ベスト手</span>
    </div>
  </div>

  <div class="card side">
    <div class="row">
      <button id="newBtn">新規ゲーム</button>
      <button id="undoBtn" class="secondary">Undo</button>
    </div>

    <div class="toggle">
      <input id="showMoveEval" type="checkbox" checked />
      <label for="showMoveEval"><b>合法手は「手の評価」を表示</b></label>
    </div>

    <div class="toggle">
      <input id="showBest" type="checkbox" checked />
      <label for="showBest"><b>ベスト手をハイライト</b></label>
    </div>

    <div class="toggle">
      <input id="showLegalDot" type="checkbox" checked />
      <label for="showLegalDot"><b>合法手の点表示</b></label>
    </div>

    <div class="stat">
      <div><span class="k">手番</span><span class="v" id="turnTxt"></span></div>
      <div><span class="k">黒</span><span class="v mono" id="blackCnt"></span></div>
      <div><span class="k">白</span><span class="v mono" id="whiteCnt"></span></div>
      <div><span class="k">合法手数</span><span class="v mono" id="legalCnt"></span></div>
      <div><span class="k">ベスト手評価</span><span class="v mono" id="bestVal"></span></div>
    </div>

    <div class="note">
      クリックで着手。合法手が無い場合は自動でパスします（両者無手で終了）。
    </div>
  </div>
</div>

<script>
(() => {
  // 盤面表現: 0=空, 1=黒, -1=白
  const N = 8;
  const EMPTY = 0, BLACK = 1, WHITE = -1;

  // 位置の重み（典型的なヒューリスティック）
  // 角を高く、角隣を低く、辺をやや高く、中央は普通
  const W = [
    [120, -20,  20,   5,   5,  20, -20, 120],
    [-20, -40,  -5,  -5,  -5,  -5, -40, -20],
    [ 20,  -5,  15,   3,   3,  15,  -5,  20],
    [  5,  -5,   3,   3,   3,   3,  -5,   5],
    [  5,  -5,   3,   3,   3,   3,  -5,   5],
    [ 20,  -5,  15,   3,   3,  15,  -5,  20],
    [-20, -40,  -5,  -5,  -5,  -5, -40, -20],
    [120, -20,  20,   5,   5,  20, -20, 120],
  ];

  // 評価の係数（分かりやすさ優先でシンプル）
  const COEF_FLIP = 2.0;      // 返せる枚数の価値
  const COEF_MOB_CUT = 3.0;   // 相手合法手の減少の価値（減るほど良い）
  const COEF_BASE = 1.0;      // 位置の重み

  const dirs = [
    [-1,-1],[-1,0],[-1,1],
    [ 0,-1],       [ 0,1],
    [ 1,-1],[ 1,0],[ 1,1],
  ];

  // State
  let board = makeInitialBoard();
  let turn = BLACK;
  let history = [];
  let bestMoveCache = null;

  const elBoard = document.getElementById('board');
  const turnTxt = document.getElementById('turnTxt');
  const blackCnt = document.getElementById('blackCnt');
  const whiteCnt = document.getElementById('whiteCnt');
  const legalCnt = document.getElementById('legalCnt');
  const bestVal = document.getElementById('bestVal');

  const showMoveEval = document.getElementById('showMoveEval');
  const showBest = document.getElementById('showBest');
  const showLegalDot = document.getElementById('showLegalDot');

  document.getElementById('newBtn').addEventListener('click', () => {
    board = makeInitialBoard();
    turn = BLACK;
    history = [];
    bestMoveCache = null;
    render();
  });
  document.getElementById('undoBtn').addEventListener('click', () => {
    const prev = history.pop();
    if (!prev) return;
    board = prev.board;
    turn = prev.turn;
    bestMoveCache = null;
    render();
  });

  showMoveEval.addEventListener('change', render);
  showBest.addEventListener('change', render);
  showLegalDot.addEventListener('change', render);

  function makeInitialBoard(){
    const b = Array.from({length:N}, () => Array(N).fill(EMPTY));
    b[3][3] = WHITE;
    b[3][4] = BLACK;
    b[4][3] = BLACK;
    b[4][4] = WHITE;
    return b;
  }

  function inBounds(r,c){ return r>=0 && r<N && c>=0 && c<N; }

  function cloneBoard(b){ return b.map(row => row.slice()); }

  function getFlips(b, r, c, player){
    if (b[r][c] !== EMPTY) return [];
    const opp = -player;
    let flips = [];
    for (const [dr,dc] of dirs){
      let rr = r+dr, cc = c+dc;
      let line = [];
      while (inBounds(rr,cc) && b[rr][cc] === opp){
        line.push([rr,cc]);
        rr += dr; cc += dc;
      }
      if (line.length > 0 && inBounds(rr,cc) && b[rr][cc] === player){
        flips = flips.concat(line);
      }
    }
    return flips;
  }

  function listLegalMoves(b, player){
    const moves = [];
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        const flips = getFlips(b,r,c,player);
        if (flips.length) moves.push({r,c,flips});
      }
    }
    return moves;
  }

  function applyMove(b, move, player){
    const nb = cloneBoard(b);
    nb[move.r][move.c] = player;
    for (const [rr,cc] of move.flips){
      nb[rr][cc] = player;
    }
    return nb;
  }

  function countDiscs(b){
    let black=0, white=0;
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        if (b[r][c] === BLACK) black++;
        if (b[r][c] === WHITE) white++;
      }
    }
    return {black, white};
  }

  // 基本評価（位置の重みの合計を「手番目線」で返す）
  // ここでは「player にとって良いほど +」にする
  function baseBoardEval(b, player){
    let sum = 0;
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        if (b[r][c] === EMPTY) continue;
        sum += W[r][c] * (b[r][c] === player ? 1 : -1);
      }
    }
    return sum;
  }

  // 「その手を打った場合」の手の評価（分かりやすいヒューリスティック）
  //  - 着手点の位置の重み
  //  - 返せる枚数
  //  - 相手の合法手数を減らす（＝相手モビリティを削る）
  function moveEval(b, move, player){
    const after = applyMove(b, move, player);

    const pos = W[move.r][move.c] * COEF_BASE;
    const flips = move.flips.length * COEF_FLIP;

    const opp = -player;
    const oppMovesBefore = listLegalMoves(b, opp).length;
    const oppMovesAfter  = listLegalMoves(after, opp).length;
    const mobilityCut = (oppMovesBefore - oppMovesAfter) * COEF_MOB_CUT;

    // おまけで盤面の位置評価も少し混ぜる（打った結果の安定度）
    const boardPosDelta = (baseBoardEval(after, player) - baseBoardEval(b, player)) * 0.05;

    return Math.round((pos + flips + mobilityCut + boardPosDelta) * 10) / 10;
  }

  function computeBestMove(b, player){
    const moves = listLegalMoves(b, player);
    if (!moves.length) return null;
    let best = null;
    for (const m of moves){
      const v = moveEval(b, m, player);
      if (!best || v > best.v) best = { ...m, v };
    }
    return best;
  }

  function tryAutoPass(){
    const moves = listLegalMoves(board, turn);
    if (moves.length) return false;
    // パス
    const oppMoves = listLegalMoves(board, -turn);
    if (!oppMoves.length){
      // 終了
      return true;
    }
    turn = -turn;
    return false;
  }

  function onCellClick(r,c){
    const moves = listLegalMoves(board, turn);
    const move = moves.find(m => m.r===r && m.c===c);
    if (!move) return;

    history.push({ board: cloneBoard(board), turn });
    board = applyMove(board, move, turn);
    turn = -turn;
    bestMoveCache = null;

    // 自動パス処理（連続パスもケア）
    let ended = false;
    for (let i=0; i<2; i++){
      const endNow = tryAutoPass();
      if (endNow){ ended = true; break; }
    }
    render(ended);
  }

  function render(ended=false){
    // Best move cache
    const legal = listLegalMoves(board, turn);
    bestMoveCache = (showBest.checked ? computeBestMove(board, turn) : null);

    // Stats
    const cnt = countDiscs(board);
    const turnName = (turn === BLACK) ? '黒' : '白';
    turnTxt.textContent = ended ? '終了' : turnName;
    blackCnt.textContent = cnt.black;
    whiteCnt.textContent = cnt.white;
    legalCnt.textContent = legal.length;
    bestVal.textContent = bestMoveCache ? bestMoveCache.v : (legal.length ? '—' : '（パス）');

    // Draw board
    elBoard.innerHTML = '';
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        const cell = document.createElement('div');
        cell.className = 'cell';

        // Click
        cell.addEventListener('click', () => onCellClick(r,c));

        const v = board[r][c];

        // Disc
        if (v !== EMPTY){
          const disc = document.createElement('div');
          disc.className = 'disc ' + (v===BLACK ? 'black' : 'white');
          cell.appendChild(disc);

          const badge = document.createElement('div');
          badge.className = 'badge';
          badge.textContent = (v===BLACK ? 'B' : 'W');
          cell.appendChild(badge);
        }

        // Evaluation display
        const evalEl = document.createElement('div');
        evalEl.className = 'eval';

        // Determine what to show
        let textVal = null;
        let isLegal = false;

        const legalMove = legal.find(m => m.r===r && m.c===c);

        if (v === EMPTY){
          // empty
          if (showMoveEval.checked && legalMove){
            isLegal = true;
            textVal = moveEval(board, legalMove, turn);
          }else{
            textVal = W[r][c];
            evalEl.classList.add('muted');
          }
        } else {
          // occupied: show its positional weight (muted) so "always"
          textVal = W[r][c];
          evalEl.classList.add('muted');
        }

        evalEl.textContent = (textVal>=0 ? `+${textVal}` : `${textVal}`);
        cell.appendChild(evalEl);

        // Legal dot
        if (v===EMPTY && legalMove && showLegalDot.checked){
          const dot = document.createElement('div');
          dot.className = 'legalDot';
          cell.appendChild(dot);
        }

        // Best highlight
        if (bestMoveCache && v===EMPTY && bestMoveCache.r===r && bestMoveCache.c===c){
          cell.classList.add('best');
        }

        elBoard.appendChild(cell);
      }
    }
  }

  // 初回レンダ & 自動パス
  tryAutoPass();
  render();
})();
</script>
</body>
</html>
